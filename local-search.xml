<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Junk-Instructions-Principle-Detection-Removal</title>
    <link href="/2025/06/22/Junk-Instructions-Principle-Detection-Removal/"/>
    <url>/2025/06/22/Junk-Instructions-Principle-Detection-Removal/</url>
    
    <content type="html"><![CDATA[<h2 id="一、花指令的原理"><a href="#一、花指令的原理" class="headerlink" title="一、花指令的原理"></a>一、花指令的原理</h2><p>​花指令的本质是干扰反汇编引擎正常工作的指令片段，不影响程序本身的执行结果。花指令可以干扰IDA 等反汇编工具生成正确的汇编代码、CFG（控制流图）、进一步干扰生成中间代码（IR）及伪代码。 对于只会使用IDA F5 功能进行逆向的人来说，简直就是致命杀手。按可执行性可分为<strong>不可执行花指令</strong>和**可执行花指令 **。但即使是可执行花指令，也不会改变程序的原功能。在x86平台，常见的<code>junk_code</code>如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">      指令                          操作码<br><span class="hljs-function"><span class="hljs-title">call</span> immed16     ----&gt;</span>    E8    <span class="hljs-comment">// 3字节指令，immed16为2字节，代表跳转指令的目的地址(16位)与下一条指令地址的偏移</span><br><span class="hljs-function"><span class="hljs-title">call</span> immed32     ----&gt;</span>    <span class="hljs-number">9</span>A    <span class="hljs-comment">// 5字节指令，immed32为4字节，代表跳转指令的目的地址(32位)与下一条指令地址的偏移</span><br><span class="hljs-function"><span class="hljs-title">jmp</span>  immed8      ----&gt;</span>    EB <br><span class="hljs-function"><span class="hljs-title">jmp</span>  immed16     ----&gt;</span>    E9 <br><span class="hljs-function"><span class="hljs-title">jmp</span>  immed32     ----&gt;</span>    EA <br><span class="hljs-function"><span class="hljs-title">loop</span> immed8      ----&gt;</span>    E2 <br><span class="hljs-function"><span class="hljs-title">ret</span>              ----&gt;</span>    C2<br><span class="hljs-function"><span class="hljs-title">retn</span>             ----&gt;</span>    C3<br></code></pre></td></tr></table></figure><p>为了能够有效的迷惑反汇编器，同时又保证代码的正确运行，花指令必须满足以下两个基本特征：</p><ul><li>垃圾数据必须是某个合法指令的一部分。</li><li>程序运行时，垃圾数据必须位于实际不可执行的代码路径。</li></ul><h2 id="1-反汇编算法与设计缺陷"><a href="#1-反汇编算法与设计缺陷" class="headerlink" title="1 反汇编算法与设计缺陷"></a>1 反汇编算法与设计缺陷</h2><p>反汇编算法分为<strong>线性扫描算法</strong>和<strong>递归下降算法</strong>(IDA)。</p><h3 id="1-1-线性扫描算法"><a href="#1-1-线性扫描算法" class="headerlink" title="1.1 线性扫描算法"></a>1.1 线性扫描算法</h3><ul><li>从入口开始，依次解析每一条指令，遇到分支指令不会递归进入分支。</li><li>线性扫描算法的缺点在于：在冯诺依曼体系结构下，<strong>无法区分数据与代码，将代码段中嵌入的数据误解释为指令操作码，最后得到错误的反汇编</strong>。</li><li>假如有一个函数 disAsm (addr) , 该函数可以对指定地址 addr 处反汇编一条指令，并将结果自动输出到屏幕，返回值是当前反汇编指令的长度。 你要如何驱动 disAsm 对一个完整的函数反汇编？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">target = getFunctionAddress(mian)<br>targetEnd = getFunctionEnd(mian)<br>currentAddr = target<br><span class="hljs-keyword">while</span> currentAddr &lt; targetEnd:<br>    currentLen = disAsm(addr)<br>    currentAddr += currentLen<br></code></pre></td></tr></table></figure><h3 id="1-2-递归下降算法"><a href="#1-2-递归下降算法" class="headerlink" title="1.2 递归下降算法"></a>1.2 递归下降算法</h3><ul><li>从入口开始，依次解析每一条指令，遇到分支指令时递归进入分支。</li><li>递归下降算法<strong>强调控制流的概念</strong>。控制流根据一条指令是否被另一条指令<strong>引用</strong>来决定是否对其进行反汇编。</li><li>递归下降算法的缺点在于：可以构造<strong>必然条件</strong>或者<strong>互补条件</strong>，使得反汇编出错。</li></ul><h3 id="1-3-如何构造欺骗采用递归下降方法的反汇编引擎？"><a href="#1-3-如何构造欺骗采用递归下降方法的反汇编引擎？" class="headerlink" title="1.3 如何构造欺骗采用递归下降方法的反汇编引擎？"></a>1.3 如何构造欺骗采用递归下降方法的反汇编引擎？</h3><p>​x86 指令集的长度不是固定的，有一些指令很短，只有1字节，有一些指令比较长，可能达到5字节， 甚至更长。不同的指令，其指令长度不是固定的。如果通过巧妙的构造，引导反汇编引擎解析一条错误的指令，扰乱解析指令的长度，就能使反汇编引擎无法按照正确的指令长度依次解析邻接未解析的指令，最终使反汇编引擎输出错误的反汇编结果。</p><h2 id="二、-花指令的识别、实现、去除"><a href="#二、-花指令的识别、实现、去除" class="headerlink" title="二、 花指令的识别、实现、去除"></a>二、 花指令的识别、实现、去除</h2><h3 id="2-1-无条件转移花指令"><a href="#2-1-无条件转移花指令" class="headerlink" title="2.1 无条件转移花指令"></a>2.1 无条件转移花指令</h3><ul><li>单次无条件转移：这种<code>jmp</code>单次跳转只能骗过线性扫描算法，<strong>会被IDA识别（递归下降）</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmp LABEL1<br>  db junk_code;<br>LABEL1:<br></code></pre></td></tr></table></figure><ul><li>多次无条件转移：和单次跳转一样，这种也会被IDA识别。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">__asm &#123;<br>    jmp LABEL1;<br>    _emit 68h;<br>LABEL1:<br>    jmp LABEL2;<br>    _emit 0CDh;<br>    _emit 20h;<br>LABEL2:<br>    jmp LABEL3;<br>    _emit 0E8h;<br>LABEL3:<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-互补跳转花指令"><a href="#2-2-互补跳转花指令" class="headerlink" title="2.2 互补跳转花指令"></a>2.2 互补跳转花指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">__asm &#123;<br>    jz Label;<br>    jnz Label;<br>    _emit 0xC7;<br>Label:<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的实现（msvc、32位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    __asm &#123;<br>        jz s;<br>        jnz s;<br>        _emit <span class="hljs-number">0xe9</span>;<br>    s:<br>    &#125;<br>    <span class="hljs-comment">// 这段asm主要的影响是0xe9会作为下一条指令的起始</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译结果：</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915223856118.png" alt="image-20250915223856118"></p><p>​这种互补跳转让ida也识别错误，只需要将<code>E9</code>改为单字节指令，并且改为单字节指令后不影响程序正常功能即可。最好的单字节指令：<strong>nop</strong>。之后ida就能正常分析。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915224216829.png" alt="image-20250915224216829"></p><h3 id="2-3-跳转构造花指令"><a href="#2-3-跳转构造花指令" class="headerlink" title="2.3 跳转构造花指令"></a>2.3 跳转构造花指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">__asm &#123;<br>    push ebx;<br>    xor ebx, ebx;<br>    test ebx, ebx;<br>    jnz LABEL7;<br>    jz    LABEL8;<br>LABEL7:<br>    _emit 0xC7;<br>LABEL8:<br>    pop ebx;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的实现（msvc、32位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    __asm &#123;<br>        push ebx;<br>        xor ebx, ebx;<br>        test ebx, ebx;<br>        jnz s1;<br>        jz  s2;<br>    s1:<br>        _emit <span class="hljs-number">0xe9</span>;<br>    s2:<br>        pop ebx;一定要恢复ebx<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ida将<code>s2</code>识别为<code>s1+1</code>。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915225047835.png" alt="image-20250915225047835"></p><p>同样patch掉E9就能正常识别。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915225222716.png" alt="image-20250915225222716"></p><h3 id="2-4-call-ret花指令"><a href="#2-4-call-ret花指令" class="headerlink" title="2.4 call&amp;ret花指令"></a>2.4 call&amp;ret花指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">__asm &#123;<br>    call LABEL9;<br>    _emit 0x83;;1字节<br>LABEL9:<br>    ;ret后不会跳转到_emit 0x83;而是跳转到汇编__emit 0xF3; 之后, 换句话说就是改变了返回地址<br>    add dword ptr ss : [esp] , 8;;5字节<br>        ret;;1字节<br>    __emit 0xF3;;1字节<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的实现（msvc、32位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    __asm &#123;<br>        call s;<br>        _emit <span class="hljs-number">0x83</span>;<br>    s:<br>        add dword ptr ss : [esp] , <span class="hljs-number">8</span>;<br>        ret;<br>        _emit <span class="hljs-number">0xf3</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合ida反汇编来解释为什么是add指令的第二个操作数是8。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915230152044.png" alt="image-20250915230152044"></p><p>​call指令会将返回地址(<strong>0x41188C</strong>)压栈，此时<code>[esp]</code>中就是返回地址，构造花指令一共使用了<code>1+5+1+1=8</code>字节的指令，因此在花指令中需要ret到正确的eip，而正确的eip是<code>[esp]+8</code>，所以<strong>add指令的第二个操作数是多少取决于用多少个字节来构造花指令</strong>。此处是8字节，花指令中ret时，[esp]已经是正确的返回地址(<strong>0x41188C+8&#x3D;0x411894</strong>)。</p><p>​patch的时候只需将所有的花指令(<strong>[0x41188C,0x411894)</strong>)改为nop即可。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915231354029.png" alt="image-20250915231354029"></p><h3 id="2-5-裸函数花指令"><a href="#2-5-裸函数花指令" class="headerlink" title="2.5 裸函数花指令"></a>2.5 裸函数花指令</h3><p>这种裸函数，<strong>能构造更复杂的花指令，实现和去除的代价也更高</strong>，下面给一个最简单的实现，函数的功能是给指针a指向的地址写入整数5。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">//naked:裸函数，编译器不维护该函数的栈帧，由程序员自己维护。</span><br><span class="hljs-type">void</span> _declspec(naked)_cdecl <span class="hljs-title function_">example5</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span>&#123;<br>__asm&#123;<br>push ebp<br>mov ebp, esp<br>sub esp, <span class="hljs-number">0x40</span>;为局部变量分配空间。<br>push ebx<br>push esi<br>push edi<br><br>;模拟初始化<br>mov eax, <span class="hljs-number">0xCCCCCCCC</span><br>mov ecx, <span class="hljs-number">0x10</span><br>;edi指向栈顶<br>lea edi, dword ptr ds : [ebp - <span class="hljs-number">0x40</span>]<br>;使用stosd指令将EAX中的值（<span class="hljs-number">0xCCCCCCCC</span>）复制到EDI指向的内存地址，共复制ECX（<span class="hljs-number">0x10</span>）次。<br>rep stos dword ptr es : [edi] <br>&#125;<br>*a = <span class="hljs-number">5</span>;<br>__asm&#123;<br>call LABEL9;<br>        ;等价于 call [eip+<span class="hljs-number">1</span>]<br>_emit <span class="hljs-number">0xE8</span>;<br>_emit <span class="hljs-number">0x01</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>LABEL9:<br>push eax;<br>push ebx;<br>lea eax, dword ptr ds : [ebp - <span class="hljs-number">0x0</span>] ; <span class="hljs-comment">//将ebp的地址存放于eax</span><br>add dword ptr ss : [eax - <span class="hljs-number">0x50</span>] , <span class="hljs-number">26</span>; <span class="hljs-comment">//该地址存放的值正好是函数返回值,</span><br><span class="hljs-comment">//不过该地址并不固定,根据调试所得。加26正好可以跳到下面的mov指令,该值也是调试计算所得</span><br>pop eax;<br>pop ebx;<br>pop eax;<br>jmp eax;<br>        ;等价于 call [eip+<span class="hljs-number">3</span>]<br>_emit <span class="hljs-number">0xE8</span>;<br>_emit <span class="hljs-number">0x03</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>mov eax, dword ptr ss : [esp - <span class="hljs-number">8</span>] ; <span class="hljs-comment">//将原本的eax值返回eax寄存器</span><br>&#125;<br>__asm&#123;<br>pop edi<br>pop esi<br>pop ebx<br>mov esp, ebp<br>pop ebp<br>ret<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br><span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>example5(b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d\n&quot;</span>, *b);<br><span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ida9.2中，无需patch就能反汇编，因为其中的花指令是由<strong>无ret的call和jmp</strong>实现的，这对ida的递归扫描算法没有任何影响。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250915234122669.png" alt="image-20250915234122669"></p><h3 id="2-6-函数返回值花指令"><a href="#2-6-函数返回值花指令" class="headerlink" title="2.6 函数返回值花指令"></a>2.6 函数返回值花指令</h3><p>​有些函数在特定情况下返回值是固定的，可以用以构造花指令。比如我们自己写的函数，返回值可以是<strong>任意非零整数</strong>，就可以自己<strong>构造永恒跳转</strong>。</p><p>​还有些API函数也是如此，比如在Win下<code>HMODULE LoadLibraryA(LPCSTR lpLibFileName);</code>函数，如果我们故意传入一个<strong>不存在</strong>的模块名称，那么他就会返回一个<strong>确定的值NULL</strong>，此时就可以通过这个函数来构造永恒跳转。</p><p>​这种花指令和跳转构造的花指令原理一致，只是需要显式的<code>xor ebx, ebx</code>，因此也不要还原<code>ebx</code>，更加隐蔽。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">#include&lt;stdio.h&gt;<br>#include&lt;Windows.h&gt;<br><br>int main() &#123;<br>LoadLibrary(L&quot;./deadbeef&quot;);<br>__asm &#123;<br>cmp eax, 0;<br>jc LABEL6_1;<br>jnc LABEL6_2;<br>LABEL6_1:<br>_emit 0xE8;<br>LABEL6_2:<br>&#125;<br>printf(&quot;Hello World!\n&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>​代码中存在<code>jc/jnc</code>，但是实际上不存在<code>deadbeef</code>这个模块，所以<code>LoadLibrary</code>返回值一点是<code>NULL</code>，只有<code>jnc</code>起作用。<strong>这种花指令的识别需要熟悉<code>api</code>函数的返回值，以及正确分析程序所需的资源和运行时环境</strong>。识别与去除需要一定的综合判断和细节。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250916000309221.png" alt="image-20250916000309221"></p><p>动态调试看程序的执行流实际跳转到什么位置，其余的junk_code直接patch即可。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250916000548664.png" alt="image-20250916000548664"></p><h3 id="2-7-指令数据复用花指令（典型的可执行花指令）"><a href="#2-7-指令数据复用花指令（典型的可执行花指令）" class="headerlink" title="2.7 指令数据复用花指令（典型的可执行花指令）"></a>2.7 指令数据复用花指令（典型的可执行花指令）</h3><p>​正常情况的代码，编译后一个字节只属于一条指令，ida在反汇编分析时，也遵循这个规。，但是如果是用_emit精心设计opcode，可以实现一个字节属于多条指令。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 可以放在任何位置的花指令</span><br>    __asm &#123;<br>        _emit <span class="hljs-number">0xeb</span>;<br>        _emit <span class="hljs-number">0xff</span>;<br>        _emit <span class="hljs-number">0xc0</span>;<br>        _emit <span class="hljs-number">0x48</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ida中如下：</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250916002947562.png" alt="image-20250916002947562"></p><p>​先解释一下指令<code>EB xx</code>，含义是：<code>jmp rel8</code>，短跳转，<code>xx</code>是一个8比特的偏移量(有符号数)。如果<code>xx = 0xff</code>，而在计算机中，整数都是以补码表示，8比特的有符号数0xff是-1。因此，<code>EB FF</code>等价于<code>jmp [eip - 1]</code>。以ida中地址为0x411887处的代码为例。执行<code>EB FF</code>前，eip &#x3D; 0x411889，执行<code>EB FF</code>后，eip &#x3D; 0x411888，等价于将已经执行过的<code>FF</code>重新执行一遍，这时候的<code>FF C0</code>和<code>48</code>分别是<code>inc eax</code>和<code>dec eax</code>。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250916004057492.png" alt="image-20250916004057492"></p><p>​等价于什么都没做。但是却让ida反汇编出错。这种花指令的识别和去除有较大难度。<strong>需要动态调试才能发现四字节的junk_code</strong>。</p><h3 id="2-8-间接跳转花指令"><a href="#2-8-间接跳转花指令" class="headerlink" title="2.8 间接跳转花指令"></a>2.8 间接跳转花指令</h3><p>​将跳转地址存于寄存器中，需要运行时才能知道具体的跳转地址。这类花指令常见于定长指令集的架构，如arm。</p><p><img src="/../images/Junk-Instructions-Principle-Detection-Removal/image-20250916014015621.png" alt="image-20250916014015621"></p><h2 id="三、花指令的分析方法"><a href="#三、花指令的分析方法" class="headerlink" title="三、花指令的分析方法"></a>三、花指令的分析方法</h2><h3 id="3-1-调试观察法"><a href="#3-1-调试观察法" class="headerlink" title="3.1 调试观察法"></a>3.1 调试观察法</h3><p>​花指令不会干扰正常代码：花指令内部如果涉及到寄存器的使用，一般会将其保存在栈中，利用这个弱点，我们可以通过观察 sp 寄存器来判断花指令的入口和出口。大部分情况下，花指令可以直接使用相同长度的 nop （0x90） 替换。</p><h3 id="3-2-花指令序列批量替换"><a href="#3-2-花指令序列批量替换" class="headerlink" title="3.2 花指令序列批量替换"></a>3.2 花指令序列批量替换</h3><p>​在上一节中，我们提到如下花指令可以插入在任意位置，以至于很可能大量出现同样的花指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm &#123;<br>    _emit <span class="hljs-number">0xeb</span>;<br>    _emit <span class="hljs-number">0xff</span>;<br>    _emit <span class="hljs-number">0xc0</span>;<br>    _emit <span class="hljs-number">0x48</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这大大降低了开发大量花指令的难度，如果我们总是一条一条的分析、patch，会花很多时间。</p><p>​考虑这种情况，我们可以将16进制数据批量查找替换：EBFFC048  —-&gt;  90909090。推荐010 Editor或者Winhex。</p><p>​注意：如果花指令的模式太短，不建议批量替换，避免破坏正常指令。</p>]]></content>
    
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>junkcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php-hash-bypass</title>
    <link href="/2024/12/31/php-hash-bypass/"/>
    <url>/2024/12/31/php-hash-bypass/</url>
    
    <content type="html"><![CDATA[<h2 id="php弱比较："><a href="#php弱比较：" class="headerlink" title="php弱比较："></a>php弱比较：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$a</span>) == <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$b</span>) &amp;&amp; <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;success&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用md5值为<strong>0e</strong>开头，后面是30个数字的字符串即可绕过。<strong>（php会把0e开头的字符串当作科学计数法表示的数。比如：1.1e22 代表数 1.1 乘 10^22，0exxxxx 代表的是 0 乘 10^xxxxx，也就是 0）</strong>，这种字符串有：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># php中MD5弱比较，常见的md5开头为0e的字符串</span><br><br><span class="hljs-meta"># QNKCDZO</span><br><span class="hljs-meta"># 240610708</span><br><span class="hljs-meta"># s878926199a</span><br><span class="hljs-meta"># s155964671a</span><br><span class="hljs-meta"># s214587387a</span><br><span class="hljs-meta"># 0e215962017</span><br><span class="hljs-meta"># s1885207154a</span><br><span class="hljs-meta"># s1836677006a</span><br><br><span class="hljs-meta"># 比如：POST a=QNKCDZO&amp;b=240610708</span><br></code></pre></td></tr></table></figure><p>如果若比较中多次进行md5或者和其他算法（如sha1）嵌套，那么需要python来爆破。比如下面的题目：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$a</span>)) == <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$b</span>))) &amp;&amp; <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;success&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用下面的python脚本来爆破：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> hashlib, itertools, re, string<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Event, Queue, cpu_count<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hash</span>(<span class="hljs-params">content: <span class="hljs-built_in">str</span>, algorithm: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    h = hashlib.new(algorithm[<span class="hljs-number">0</span>], content.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest()<br>    <span class="hljs-keyword">for</span> algo <span class="hljs-keyword">in</span> algorithm[<span class="hljs-number">1</span>:]:<br>        h = hashlib.new(algo, h.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest()<br>    <span class="hljs-keyword">return</span> h<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">prefixes, charset, remain_len, algorithm, pat_str, stop_event: Event, out_q: Queue</span>):<br>    pat = re.<span class="hljs-built_in">compile</span>(pat_str)<br>    join = <span class="hljs-string">&#x27;&#x27;</span>.join<br>    <span class="hljs-keyword">for</span> pre <span class="hljs-keyword">in</span> prefixes:<br>        <span class="hljs-keyword">if</span> stop_event.is_set():<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> suff <span class="hljs-keyword">in</span> itertools.product(charset, repeat=remain_len):<br>            <span class="hljs-keyword">if</span> stop_event.is_set():<br>                <span class="hljs-keyword">return</span><br>            s = pre + join(suff)<br>            h = get_hash(s, algorithm)<br>            <span class="hljs-keyword">if</span> pat.<span class="hljs-keyword">match</span>(h):<br>                out_q.put((s, h))<br>                stop_event.<span class="hljs-built_in">set</span>()<br>                <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_mp</span>(<span class="hljs-params">algorithm=[<span class="hljs-string">&#x27;md5&#x27;</span>,<span class="hljs-string">&#x27;md5&#x27;</span>], charset=string.digits+string.ascii_letters, length=<span class="hljs-number">5</span>, nprocs=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-comment"># 目标：双 md5 命中 0e + 30 位数字</span><br>    pat_str = <span class="hljs-string">r&#x27;^0e\d&#123;30&#125;$&#x27;</span><br>    nprocs = nprocs <span class="hljs-keyword">or</span> cpu_count()<br><br>    <span class="hljs-comment"># 选择前缀长度，使 prefix 个数 &gt;= 进程数</span><br>    k = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(charset) ** k) &lt; nprocs <span class="hljs-keyword">and</span> k &lt; length:<br>        k += <span class="hljs-number">1</span><br>    k = <span class="hljs-built_in">min</span>(k, length)<br>    prefixes = [<span class="hljs-string">&#x27;&#x27;</span>.join(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> itertools.product(charset, repeat=k)]<br>    remain_len = length - k<br><br>    <span class="hljs-comment"># 切成 nprocs 份</span><br>    chunks = [prefixes[i::nprocs] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nprocs)]<br><br>    stop_event = Event()<br>    out_q = Queue()<br>    procs = [<br>        Process(target=worker, args=(chunk, charset, remain_len, algorithm, pat_str, stop_event, out_q))<br>        <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks <span class="hljs-keyword">if</span> chunk<br>    ]<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> procs: p.start()<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> procs: p.join()<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> out_q.empty():<br>        <span class="hljs-keyword">return</span> out_q.get()<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Not Found&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 对应 php: md5(md5($a))</span><br>    <span class="hljs-built_in">print</span>(brute_mp(algorithm=[<span class="hljs-string">&#x27;md5&#x27;</span>,<span class="hljs-string">&#x27;md5&#x27;</span>], charset=string.digits+string.ascii_letters, length=<span class="hljs-number">5</span>))<br><br>    <span class="hljs-comment"># 对应 php: md5($c)</span><br>    <span class="hljs-built_in">print</span>(brute_mp(algorithm=[<span class="hljs-string">&#x27;md5&#x27;</span>], charset=string.digits+string.ascii_letters, length=<span class="hljs-number">5</span>))<br><br>    <span class="hljs-comment"># 对应 php: sha1(sha1(sha1($b)))，记得把正则改成 ^0e\d&#123;38&#125;$（如果要爆 sha1）</span><br>    <span class="hljs-comment"># print(brute_mp(algorithm=[&#x27;sha1&#x27;]*3, charset=string.digits+string.ascii_letters, length=5))</span><br></code></pre></td></tr></table></figure><p>会占用很多cpu资源，爆破很久，爆破出一些结果(双md5)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-string">&#x27;f2WfQ&#x27;</span>, <span class="hljs-string">&#x27;0e997766059721689977306698103413&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="php强比较"><a href="#php强比较" class="headerlink" title="php强比较"></a>php强比较</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$a</span>) === <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$b</span>) &amp;&amp; <span class="hljs-variable">$a</span> !== <span class="hljs-variable">$b</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;success&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用数组即可绕过。<strong>因为php中的数组经过md5处理</strong>，得到的是null。null &#x3D;&#x3D;&#x3D; null。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"># POST a<span class="hljs-comment">[]</span>=1&amp;b<span class="hljs-comment">[]</span>=2<br></code></pre></td></tr></table></figure><h2 id="字符串强比较"><a href="#字符串强比较" class="headerlink" title="字符串强比较"></a>字符串强比较</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$a</span>) === <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$b</span>) &amp;&amp; (<span class="hljs-keyword">string</span>)<span class="hljs-variable">$a</span> !== (<span class="hljs-keyword">string</span>)<span class="hljs-variable">$b</span>)<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;success&#x27;</span>;<br><br><span class="hljs-variable">$arr1</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-variable">$arr2</span> = <span class="hljs-keyword">array</span>();<br><span class="hljs-keyword">echo</span> (<span class="hljs-keyword">string</span>)<span class="hljs-variable">$arr1</span>, <span class="hljs-string">&quot;\n&quot;</span>, (<span class="hljs-keyword">string</span>)<span class="hljs-variable">$arr2</span>, <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-comment">// Array</span><br><span class="hljs-comment">// Array</span><br><span class="hljs-comment">// 无论数组中是什么内容，都会被转换为Array，所以这个不能用数组绕过</span><br></code></pre></td></tr></table></figure><p>此时数组不能绕过了，可以使用碰撞：[fastcoll](<a href="https://github.com/brimstone/fastcoll?tab=readme-ov-file">GitHub - brimstone&#x2F;fastcoll</a>)。</p><h3 id="fastcoll"><a href="#fastcoll" class="headerlink" title="fastcoll"></a>fastcoll</h3><p>这个工具的作用是生成两个内容不同但md5相同的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译fastcoll</span><br>wget https://github.com/brimstone/fastcoll/archive/refs/heads/master.zip<br>unzip master.zip<br>cd fastcoll-master/<br>sudo apt install libboost1.74-all-dev<br>g++ *.cpp -std=c++11 -lboost_program_options -lboost_filesystem -o fastcoll-static -static<br>g++ *.cpp -std=c++11 -lboost_program_options -lboost_filesystem -o fastcoll<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用fastcoll生成两个md5相同内容不同的文件</span><br>./fastcoll -o a1.bin a2.bin<br>cp *.bin ..<br></code></pre></td></tr></table></figure><p>工具的使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fastcoll -o a1.bin a2.bin<br></code></pre></td></tr></table></figure><p>将碰撞出来的文件使用yakit读取，并且url编码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apppple=&#123;&#123;url(&#123;&#123;file(C:\Users\zhao\Desktop\a1.bin)&#125;&#125;)&#125;&#125;&amp;banananana=&#123;&#123;url(&#123;&#123;file(C:\Users\zhao\Desktop\a2.bin)&#125;&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要用Yakit？</strong> 因为php和python的urlencode的结果发送出去都不行，离谱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自己实现的url全编码，但是发出去也不对</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">file2urlencode</span>(<span class="hljs-params">file_path</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        binary_content = file.read()<br>    url_encoded_content=<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&quot;%&quot;</span>+<span class="hljs-built_in">hex</span>(c)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> binary_content])<br>    <span class="hljs-keyword">return</span> url_encoded_content<br><br><span class="hljs-built_in">print</span>(file2urlencode(<span class="hljs-string">&#x27;./a1.bin&#x27;</span>))<br><span class="hljs-built_in">print</span>(file2urlencode(<span class="hljs-string">&#x27;./a2.bin&#x27;</span>))<br></code></pre></td></tr></table></figure><p>下面的php也是不行的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;a1.bin&#x27;</span>)), <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;a2.bin&#x27;</span>)), <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="MD5长度扩展攻击"><a href="#MD5长度扩展攻击" class="headerlink" title="MD5长度扩展攻击"></a>MD5长度扩展攻击</h2><p>原理自行上网了解。<br>攻击需要已知明文的<strong>长度</strong>和该明文对应的<strong>MD5</strong>值。<br>攻击脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack, unpack<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> floor, sin<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MD5</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.A, <span class="hljs-variable language_">self</span>.B, <span class="hljs-variable language_">self</span>.C, <span class="hljs-variable language_">self</span>.D = \<br>            (<span class="hljs-number">0x67452301</span>, <span class="hljs-number">0xefcdab89</span>, <span class="hljs-number">0x98badcfe</span>, <span class="hljs-number">0x10325476</span>)  <span class="hljs-comment"># initial values</span><br>        <span class="hljs-variable language_">self</span>.r: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>] = \<br>            [<span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22</span>] * <span class="hljs-number">4</span> + [<span class="hljs-number">5</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>] * <span class="hljs-number">4</span> + \<br>            [<span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>] * <span class="hljs-number">4</span> + [<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>] * <span class="hljs-number">4</span>  <span class="hljs-comment"># shift values</span><br>        <span class="hljs-variable language_">self</span>.k: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>] = \<br>            [floor(<span class="hljs-built_in">abs</span>(sin(i + <span class="hljs-number">1</span>)) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>))<br>             <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>)]  <span class="hljs-comment"># constants</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_lrot</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> (x &lt;&lt; n) | (x &gt;&gt; <span class="hljs-number">32</span> - n)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, chunk: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        w = <span class="hljs-built_in">list</span>(unpack(<span class="hljs-string">&#x27;&lt;&#x27;</span>+<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>, chunk))<br>        a, b, c, d = <span class="hljs-variable language_">self</span>.A, <span class="hljs-variable language_">self</span>.B, <span class="hljs-variable language_">self</span>.C, <span class="hljs-variable language_">self</span>.D<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">16</span>:<br>                f = (b &amp; c) | ((~b) &amp; d)<br>                flag = i<br>            <span class="hljs-keyword">elif</span> i &lt; <span class="hljs-number">32</span>:<br>                f = (b &amp; d) | (c &amp; (~d))<br>                flag = (<span class="hljs-number">5</span> * i + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span><br>            <span class="hljs-keyword">elif</span> i &lt; <span class="hljs-number">48</span>:<br>                f = (b ^ c ^ d)<br>                flag = (<span class="hljs-number">3</span> * i + <span class="hljs-number">5</span>) % <span class="hljs-number">16</span><br>            <span class="hljs-keyword">else</span>:<br>                f = c ^ (b | (~d))<br>                flag = (<span class="hljs-number">7</span> * i) % <span class="hljs-number">16</span><br>            tmp = b+<span class="hljs-variable language_">self</span>._lrot((a+f+<span class="hljs-variable language_">self</span>.k[i] + w[flag]) &amp; <span class="hljs-number">0xffffffff</span>, <span class="hljs-variable language_">self</span>.r[i])<br>            a, b, c, d = d, tmp &amp; <span class="hljs-number">0xffffffff</span>, b, c<br>        <span class="hljs-variable language_">self</span>.A = (<span class="hljs-variable language_">self</span>.A + a) &amp; <span class="hljs-number">0xffffffff</span><br>        <span class="hljs-variable language_">self</span>.B = (<span class="hljs-variable language_">self</span>.B + b) &amp; <span class="hljs-number">0xffffffff</span><br>        <span class="hljs-variable language_">self</span>.C = (<span class="hljs-variable language_">self</span>.C + c) &amp; <span class="hljs-number">0xffffffff</span><br>        <span class="hljs-variable language_">self</span>.D = (<span class="hljs-variable language_">self</span>.D + d) &amp; <span class="hljs-number">0xffffffff</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">self, msg: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(msg) % <span class="hljs-number">64</span> == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(msg), <span class="hljs-number">64</span>):<br>            <span class="hljs-variable language_">self</span>.update(msg[i:i + <span class="hljs-number">64</span>])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">padding</span>(<span class="hljs-params">self, msg: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>        length = pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, <span class="hljs-built_in">len</span>(msg) * <span class="hljs-number">8</span>)<br>        msg += <span class="hljs-string">b&#x27;\x80&#x27;</span><br>        msg += <span class="hljs-string">b&#x27;\x00&#x27;</span> * ((<span class="hljs-number">56</span> - <span class="hljs-built_in">len</span>(msg)) % <span class="hljs-number">64</span>)<br>        msg += length<br>        <span class="hljs-keyword">return</span> msg<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">digest</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>        <span class="hljs-keyword">return</span> pack(<span class="hljs-string">&#x27;&lt;IIII&#x27;</span>, <span class="hljs-variable language_">self</span>.A, <span class="hljs-variable language_">self</span>.B, <span class="hljs-variable language_">self</span>.C, <span class="hljs-variable language_">self</span>.D)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params">message_len: <span class="hljs-built_in">int</span>, known_hash: <span class="hljs-built_in">str</span>, append_str: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:<br>    md5 = MD5()<br>    previous_text = md5.padding(<span class="hljs-string">b&quot;*&quot;</span> * message_len)<br>    current_text = previous_text + append_str<br>    md5.A, md5.B, md5.C, md5.D = unpack(<span class="hljs-string">&quot;&lt;IIII&quot;</span>, <span class="hljs-built_in">bytes</span>.fromhex(known_hash))<br>    md5.extend(md5.padding(current_text)[<span class="hljs-built_in">len</span>(previous_text):])<br>    <span class="hljs-keyword">return</span> current_text[message_len:], md5.digest().<span class="hljs-built_in">hex</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    message_len = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[&gt;] Input known text length: &quot;</span>))<br>    known_hash = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[&gt;] Input known hash: &quot;</span>).strip()<br>    append_text = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[&gt;] Input append text: &quot;</span>).strip().encode()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Attacking...&quot;</span>)<br>    extend_str, final_hash = attack(message_len, known_hash, append_text)<br>    <span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> quote<br>    <span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> b64encode<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Extend text:&quot;</span>, extend_str)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Extend text (URL encoded):&quot;</span>, quote(extend_str))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Extend text (Base64):&quot;</span>, b64encode(extend_str).decode())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Final hash:&quot;</span>, final_hash)<br></code></pre></td></tr></table></figure><p>例题：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><br><span class="hljs-comment">// 你以为这就结束了</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;random&#x27;</span>])) &#123;<br><span class="hljs-comment">// 这里的长度可以自己计算   为96</span><br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;random&#x27;</span>] = <span class="hljs-title function_ invoke__">bin2hex</span>(<span class="hljs-title function_ invoke__">random_bytes</span>(<span class="hljs-number">16</span>)) . <span class="hljs-title function_ invoke__">bin2hex</span>(<span class="hljs-title function_ invoke__">random_bytes</span>(<span class="hljs-number">16</span>)) . <span class="hljs-title function_ invoke__">bin2hex</span>(<span class="hljs-title function_ invoke__">random_bytes</span>(<span class="hljs-number">16</span>));<br>&#125;<br><br><span class="hljs-comment">// 你想看到 random 的值吗?</span><br><span class="hljs-comment">// 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧</span><br><span class="hljs-variable">$random</span> = <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;random&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$random</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br><br><span class="hljs-variable">$name</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;name&#x27;</span>] ?? <span class="hljs-string">&#x27;user&#x27;</span>;<br><br><span class="hljs-comment">// check if name ends with &#x27;admin&#x27;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$name</span>, -<span class="hljs-number">5</span>) !== <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;不是管理员也来凑热闹?&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable">$md5</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;md5&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$random</span> . <span class="hljs-variable">$name</span>) !== <span class="hljs-variable">$md5</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;伪造? NO NO NO!&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 认输了, 看样子你真的很懂 MD5</span><br><span class="hljs-comment">// 那 flag 就给你吧</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;看样子你真的很懂 MD5&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>);<br></code></pre></td></tr></table></figure><p>payload：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: gz.imxbt.cn:<span class="hljs-number">20692</span><br><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span><br><span class="hljs-attribute">Cookie</span>: PHPSESSID=<span class="hljs-number">8</span>f6e3i7s91v0a2lah6g5gk7j16<br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">131.0.0.0</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> Edg/<span class="hljs-number">131.0.0.0</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,application/signed-exchange;v=b3;q=<span class="hljs-number">0</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate<br><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,en;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,en-GB;q=<span class="hljs-number">0</span>.<span class="hljs-number">7</span>,en-US;q=<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">DNT</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<br><br><span class="hljs-attribute">md5</span>=bee0e0cbd622a1e162536bd3ad9ea067&amp;name=%<span class="hljs-number">80</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">03</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>admin<br></code></pre></td></tr></table></figure><h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><p>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a>许可协议。转载请注明来源：<a href="https://zhaoyinshan.github.io/">学无止境-YS Zhao</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>bypass</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
